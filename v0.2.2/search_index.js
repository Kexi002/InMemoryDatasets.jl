var documenterSearchIndex = {"docs":
[{"location":"man/basics/#First-steps-with-Datasets","page":"First Steps","title":"First steps with Datasets","text":"","category":"section"},{"location":"man/basics/#Setting-up-the-environment","page":"First Steps","title":"Setting up the environment","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To install in memory Datasets package , simply, use the following commands inside a Julia session:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> using Pkg\njulia> Pkg.add(\"InMemoryDatasets\")","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Throughout the rest of the tutorial we will assume that you have installed the \"In Memory Datasets\" package and have already typed using InMemoryDatasets which loads the package:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> using InMemoryDatasets","category":"page"},{"location":"man/basics/#Creating-a-data-set","page":"First Steps","title":"Creating a data set","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To create a data set, use Dataset(). For example","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(var1 = [1, 2, 3],\n                var2 = [1.2, 0.5, 3.3],\n                var3 = [\"C1\", \"C2\", \"C3\"])\n3×3 Dataset\n Row │ var1      var2      var3\n     │ identity  identity  identity\n     │ Int64?    Float64?  String?\n─────┼────────────────────────────────\n   1 │        1       1.2  C1\n   2 │        2       0.5  C2\n   3 │        3       3.3  C3","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The first line of the output provides the general information about the data set.  A data set is shown as a table in Julia, where each column represents a variable  in the data set. The header section of the table shows three pieces of information  for each column (variable), the column's name, the column's format, and  the column's data type. The format of a column controls how the values  of a column should be shown or interpreted when working with a data set.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The following example shows how to create a data set by providing a range of values.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset(A=1:3, B=5:7, fixed=1)\n3×3 Dataset\n Row │ A         B         fixed\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        1         5         1\n   2 │        2         6         1\n   3 │        3         7         1","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Observe that using scalars for a column, like 1 for the column :fixed get automatically broadcasted to fill all rows of the created Dataset.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The missing values in Julia are declare as missing, and these values can also be an observation for a particular column, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset(a = [1.1, -10.0, missing], b = 1:3)\n3×2 Dataset\n Row │ a          b\n     │ identity   identity\n     │ Float64?   Int64?\n─────┼─────────────────────\n   1 │       1.1         1\n   2 │     -10.0         2\n   3 │ missing           3","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Sometimes one needs to create a data set whose column names are not valid Julia identifiers. In such a case the following form where column names are passed as strings, and = is replaced by => is handy:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset(\"customer age\" => [15, 20, 25],\n                 \"first name\" => [\"Ben\", \"Steve\", \"Jule\"])\n3×2 Dataset\nRow │ customer age  first name\n    │ identity      identity\n    │ Int64?        String?\n────┼───────────────────────────\n  1 │           15  Ben\n  2 │           20  Steve\n  3 │           25  Jule","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"It is also possible to construct a data set from the values of a matrix or a vector of vectors, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset([1 0; 2 0], :auto)\n2×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         0\n   2 │        2         0\n\njulia> Dataset([[1 ,2], [0, 0]], :auto)\n2×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         0\n   2 │        2         0","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Note that the column names are generated automatically when :auto is set as the second argument.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Alternatively you can pass a vector of column names as a second argument to the Dataset:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset([1 0; 2 0], [\"col1\", \"col2\"])\n2×2 Dataset\n Row │ col1      col2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         0\n   2 │        2         0","category":"page"},{"location":"man/basics/#Basic-utility-functions","page":"First Steps","title":"Basic utility functions","text":"","category":"section"},{"location":"man/basics/#Getting-meta-information-about-a-data-set","page":"First Steps","title":"Getting meta information about a data set","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To get information about a data set, use the content function. It provides meta information about a data set.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(g = [1, 1, 1, 2, 2],\n                   x1_int = [0, 0, 1, missing, 2],\n                   x2_int = [3, 2, 1, 3, -2],\n                   x1_float = [1.2, missing, -1.0, 2.3, 10],\n                   x2_float = [missing, missing, 3.0, missing, missing],\n                   x3_float = [missing, missing, -1.4, 3.0, -100.0])\n5×6 Dataset\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float\n     │ identity  identity  identity  identity   identity   identity\n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?\n─────┼───────────────────────────────────────────────────────────────\n   1 │        1         0         3        1.2  missing    missing\n   2 │        1         0         2  missing    missing    missing\n   3 │        1         1         1       -1.0        3.0       -1.4\n   4 │        2   missing         3        2.3  missing          3.0\n   5 │        2         2        -2       10.0  missing       -100.0\n\njulia> content(ds)\n5×6 Dataset\n   Created: 2021-08-04T13:11:53.743\n  Modified: 2021-08-04T13:11:53.743\n      Info:\n-----------------------------------\nVariables information\n┌──────────┬──────────┬─────────┐\n│ var      │ format   │ eltype  │\n├──────────┼──────────┼─────────┤\n│ g        │ identity │ Int64   │\n│ x1_int   │ identity │ Int64   │\n│ x2_int   │ identity │ Int64   │\n│ x1_float │ identity │ Float64 │\n│ x2_float │ identity │ Float64 │\n│ x3_float │ identity │ Float64 │\n└──────────┴──────────┴─────────┘","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"content shows that the data set has 5 rows and 6 columns. It also shows when the data set has been created and when is the last time that it has been modified. The content function also reports the data type and formats of each variable.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The Info field is a string field which can contain any information related to the data set. To set an Info for a data set, use setinfo!, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> setinfo!(ds, \"An example from the manual\")\n\"An example from the manual\"","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"This information will be attached to the data set ds.","category":"page"},{"location":"man/basics/#Setting-and-removing-formats","page":"First Steps","title":"Setting and removing formats","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To set a specific format for a column of a data set use setformat! function, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(x = 1:10,\n                    y = repeat(1:5, inner = 2),\n                    z = repeat(1:2, 5))\n10×3 Dataset\n Row │ x         y         z\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        1         1         1\n   2 │        2         1         2\n   3 │        3         2         1\n   4 │        4         2         2\n   5 │        5         3         1\n   6 │        6         3         2\n   7 │        7         4         1\n   8 │        8         4         2\n   9 │        9         5         1\n  10 │       10         5         2\n\njulia> setformat!(ds, :y => sqrt)\n10×3 Dataset\n Row │ x         y        z\n     │ identity  sqrt     identity\n     │ Int64?    Int64?   Int64?\n─────┼─────────────────────────────\n   1 │        1  1.0             1\n   2 │        2  1.0             2\n   3 │        3  1.41421         1\n   4 │        4  1.41421         2\n   5 │        5  1.73205         1\n   6 │        6  1.73205         2\n   7 │        7  2.0             1\n   8 │        8  2.0             2\n   9 │        9  2.23607         1\n  10 │       10  2.23607         2","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The first argument for setformat! is the data set which needs to be modified and the second argument is the name of column, =>, and a named function. In the above example, we assign sqrt function as a format for the column :y.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Note that setformat! doesn't check the validity of a format, so if an invalid format is assigned to a column, for instance assigning sqrt to a column which contains negative values, some functionality of data set will be parallelised (like showing the data set). In this cases, simply remove the invalid format by using removeformat!.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Let's define a function as a new format for column :z in the above example,","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> function gender(x)\n          x == 1 ? \"Male\" : x == 2 ? \"Female\" : missing\n       end","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The format gender accepts one value and if the value is equal to 1, gender maps it to \"Male\", if the value is equal to 2, it maps it to \"Female\", and for any other values it maps them to missing.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> setformat!(ds, :z => gender)\n10×3 Dataset\n Row │ x         y        z\n     │ identity  sqrt     gender\n     │ Int64?    Int64?   Int64?\n─────┼───────────────────────────\n   1 │        1  1.0        Male\n   2 │        2  1.0      Female\n   3 │        3  1.41421    Male\n   4 │        4  1.41421  Female\n   5 │        5  1.73205    Male\n   6 │        6  1.73205  Female\n   7 │        7  2.0        Male\n   8 │        8  2.0      Female\n   9 │        9  2.23607    Male\n  10 │       10  2.23607  Female","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"the removeformat! function should be used to remove a column's format.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> removeformat!(ds, :y)\n10×3 Dataset\n Row │ x         y         z\n     │ identity  identity  gender\n     │ Int64?    Int64?    Int64?\n─────┼────────────────────────────\n   1 │        1         1    Male\n   2 │        2         1  Female\n   3 │        3         2    Male\n   4 │        4         2  Female\n   5 │        5         3    Male\n   6 │        6         3  Female\n   7 │        7         4    Male\n   8 │        8         4  Female\n   9 │        9         5    Male\n  10 │       10         5  Female","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Similar to setformat! the first argument is the name of the data set and the second argument is the name of the column which we want to remove its format. Note that assigning or removing a format doesn't change the actual values of the column.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"By default, formatted values of a column will be used when operations like displaying, sorting, grouping, or joining are called.","category":"page"},{"location":"man/basics/#Accessing-individual-column-or-observation","page":"First Steps","title":"Accessing individual column or observation","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"ds[:, col], ds[i, col] can be used to access a specific column or specific observation of a specific column of ds, respectively. For example,","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(x = [4,6,3], y = [1,2,43]);\njulia> ds[:, :x]\n3-element Vector{Union{Missing, Int64}}:\n 4\n 6\n 3\n\njulia> ds[3, :y]\n43","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Note that ds[:, col] extracts (copy) a column of a data set as a vector. Thus, this vector can be used as a normal vector in Julia.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Also note that, assigning a new value to ds[3, :y] will modify the data set, i.e.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds[3, :y] = 3\n3\n\njulia> ds\n3×2 Dataset\n Row │ x         y\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        4         1\n   2 │        6         2\n   3 │        3         3\n\njulia> content(ds)\n3×2 Dataset\n   Created: 2021-08-04T13:18:51.185\n  Modified: 2021-08-04T13:24:33.086\n      Info:\n-----------------------------------\nVariables information\n┌─────┬──────────┬────────┐\n│ var │ format   │ eltype │\n├─────┼──────────┼────────┤\n│ x   │ identity │ Int64  │\n│ y   │ identity │ Int64  │\n└─────┴──────────┴────────┘","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The content function shows that the data set has been created on 2021-08-04T13:18:51.185, and the last time that it has been modified is on 2021-08-04T13:24:33.086.","category":"page"},{"location":"man/basics/#Adding-a-new-column","page":"First Steps","title":"Adding a new column","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To add a new column (variable) to a data set use ds.newvar or ds[:, :newvar] syntax,","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(var1 = [1, 2, 3])\n3×1 Dataset\n Row │ var1\n     │ identity\n     │ Int64?\n─────┼──────────\n   1 │        1\n   2 │        2\n   3 │        3\n\njulia> ds.var2 = [\"val1\", \"val2\", \"val3\"]\n3-element Vector{String}:\n \"val1\"\n \"val2\"\n \"val3\"\n\njulia> ds\n3×2 Dataset\n Row │ var1      var2\n     │ identity  identity\n     │ Int64?    String?\n─────┼──────────────────────\n   1 │        1  val1\n   2 │        2  val2\n   3 │        3  val3\n\njulia> ds[:, :var3] = [3.5, 4.6, 32.0]\n3-element Vector{Float64}:\n  3.5\n  4.6\n 32.0\n\njulia> ds\n3×3 Dataset\n Row │ var1      var2        var3\n     │ identity  identity    identity\n     │ Int64?    String?     Float64?\n─────┼────────────────────────────────\n   1 │        1  val1             3.5\n   2 │        2  val2             4.6\n   3 │        3  val3            32.0","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Be aware that, when adding a new column to a data set, using the above syntax, if the column already exists in the data set it will be replaced by new one.","category":"page"},{"location":"man/basics/#Some-useful-functions","page":"First Steps","title":"Some useful functions","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The following functions are very handy when working with a data set. Note that functions which end with ! modify the original data set.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"names(ds) gives the column names as a vector of string.\nsize(ds) prints the data set dimension, i.e. number of rows and number of columns\nnrow(ds) returns the number of rows\nncol(ds) returns the number of columns\nfirst(ds, n) shows the first n rows of a data set\nlast(ds, n) shows the last n rows of a data set\nrename! can be used to rename column names\nselect! can be used to drop, select, or rearrange columns\ndelete! deletes rows from a data set\nappend!(ds, tds) appends tds at the end of ds","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> test_data = Dataset(rand(1:10, 4, 3), :auto)\n4×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        5        10         5\n   2 │        3         8        10\n   3 │        1         7         7\n   4 │        2         6         5\n\njulia> names(test_data)\n3-element Vector{String}:\n \"x1\"\n \"x2\"\n \"x3\"\n\njulia> size(test_data)\n(4, 3)\n\njulia> nrow(test_data)\n4\n\njulia> ncol(test_data)\n3\n\njulia> first(test_data, 3)\n3×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        5        10         5\n   2 │        3         8        10\n   3 │        1         7         7\n\njulia> last(test_data, 2)\n2×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        1         7         7\n   2 │        2         6         5\n\njulia> rename!(test_data, :x1 => :var1)\n4×3 Dataset\n Row │ var1      x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        5        10         5\n   2 │        3         8        10\n   3 │        1         7         7\n   4 │        2         6         5\n\njulia> select!(test_data, :x2, :var1)\n4×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        8         3\n   3 │        7         1\n   4 │        6         2\n\njulia> test_data\n4×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        8         3\n   3 │        7         1\n   4 │        6         2\n\njulia> delete!(test_data, 2)\n3×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        7         1\n   3 │        6         2\n\njulia> second_data = Dataset(var1 = [1, 3, 5, 6, 6],\n                             x2 = [3, 4,5,6, 3])\n5×2 Dataset\n Row │ var1      x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         3\n   2 │        3         4\n   3 │        5         5\n   4 │        6         6\n   5 │        6         3\n\njulia> append!(test_data, second_data)\n8×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        7         1\n   3 │        6         2\n   4 │        3         1\n   5 │        4         3\n   6 │        5         5\n   7 │        6         6\n   8 │        3         6","category":"page"},{"location":"man/tutorial/#Getting-Started","page":"Tutorial","title":"Getting Started","text":"","category":"section"},{"location":"lib/functions/","page":"-","title":"-","text":"<!– ```@meta CurrentModule = InMemoryDatasets","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n# Functions\n","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@index Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Constructing data set","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs copy similar","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Formats","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs removeformat! setformat!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Summary information","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs content ncol ndims nrow setinfo! size","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Working with column names","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs names propertynames rename rename!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Mutating and transforming data sets","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs append! combine flatten hcat insertcols! map map! modify modify! push! repeat repeat! select select! update update!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Transposing and reshaping data sets","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs transpose","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Sorting","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs sort sort! sortperm","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Joining","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs antijoin antijoin! closejoin closejoin! innerjoin leftjoin leftjoin! outerjoin semijoin semijoin!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Grouping","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs groupby groupby! ungroup!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Filtering rows","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs byrow contains delete! empty empty! first last mask unique unique!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Working with missing values","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs byrow completecases dropmissing dropmissing! map map!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Statistics","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs lag lead maximum mean median minimum rescale stdze sum topk var std wmean wsum ``` –>","category":"page"},{"location":"man/formats/#Formats","page":"Formats","title":"Formats","text":"","category":"section"},{"location":"man/formats/#Introduction","page":"Formats","title":"Introduction","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"format is a named function that is assigned to a column (variable). The format of a column will be called on the individual values of the column before some operations (like show, sort,...) are done on the data set. Each column (variable) in a data set has a format property. The initial format of any column is identity, however, setformat! and removeformat! can be used to modify the format of columns in a data set. By default, the format of a column will be shown in the header when a data set is displayed.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The format of a column doesn't change the actual values of the column, thus, the actual  values of a column will be untouched during adding or removing formats.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The processing of format is lazy, i.e. Datasets doesn't process format unless an operation needs to access the formatted values. This also means that modifying the format of a column is instance. However, be aware that modifying a column's format changes the modified meta information (i.e. the last time that the data set has been modified) of the data set.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In this section, we discuss the overall aspects of format and we postpone the practical use case of format to later sections when we introduce operations which access the formatted values.","category":"page"},{"location":"man/formats/#Examples","page":"Formats","title":"Examples","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In this example, we create a simple data set and assign iseven function as the format for :x1, by using setformat!(ds, 1 => iseven), note that we can also use the columns' names to assign format, i.e. the function can be called like setformat!(ds, :x1 => iseven). After calling setformat!, the format of the column will be set, and from this point any operation which support format will use these formatted values. One of the operations which uses formatted values is show. For instance, in the following example, the printed data set shows the formatted values.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ds = Dataset(x1 = 1:5, x2 = [1,2,1,2,1])\n5×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         1\n   2 │        2         2\n   3 │        3         1\n   4 │        4         2\n   5 │        5         1\njulia> setformat!(ds, 1 => iseven)\n5×2 Dataset\n Row │ x1      x2\n     │ iseven  identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │  false         1\n   2 │   true         2\n   3 │  false         1\n   4 │   true         2\n   5 │  false         1\n\njulia> ds[1,1] # note that the actual value is not changed\n1","category":"page"},{"location":"man/formats/#Manipulating-formats","page":"Formats","title":"Manipulating formats","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"There are two functions that are handy for manipulating the columns' formats, setformat! and removeformat!.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"setformat! and removeformat! are for setting and removing columns' format, respectively. The syntax of these functions are","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"setformat!(ds, arg...)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"removeformat!(ds, cols...)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"For setformat! each arg in the argument must be of the cols => fmt form, where fmt is the named function and cols is either column(s) name(s), column(s) index(s), or regular expression, thus, expressions like setformat!(ds, 1:10=>sqrt), setformat!(ds, r\"x\"=>iseven, :y=>sqrt) are valid in Datasets. When cols refers to more than one column, fmt will be assigned to all of those columns.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"For removeformat! each cols in the argument must be either column(s) name(s), column(s) index(s), or regular expression.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"Beside these two functions, there exists the getformat function to query format of a column. The syntax of getformat is","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"getformat(ds, col)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"where col is a single column identifier, i.e. column index or column's name.","category":"page"},{"location":"man/formats/#Examples-2","page":"Formats","title":"Examples","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In the following example we assign user defined functions as the format for the first and the last column and use the month function (predefined in Julia Dates) as the format for the column :date. Note that, the actual values of columns haven't been modified, they are only shown with the formatted value. As you may observe, the formatted value can help us to scan easily the sale of each store in different month","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> sale = Dataset(store = [\"store1\", \"store1\", \"store2\",\n \t\t\t\t\"store2\", \"store3\", \"store3\", \"store3\"],\n\t\t\t\tdate = [Date(\"2020-05-01\"), Date(\"2020-06-01\"),\n\t\t\t\tDate(\"2020-05-01\"), Date(\"2020-06-01\"),\n\t\t\t\tDate(\"2020-05-01\"), Date(\"2020-06-01\"), Date(\"2020-07-01\")],\n\t\t\t\tsale = [10000, 10100, 20020, 21000, 20300, 20400, 5000])\n7×3 Dataset\n Row │ store       date        sale\n     │ identity    identity    identity\n     │ String?     Date?       Int64?\n─────┼──────────────────────────────────\n   1 │ store1      2020-05-01     10000\n   2 │ store1      2020-06-01     10100\n   3 │ store2      2020-05-01     20020\n   4 │ store2      2020-06-01     21000\n   5 │ store3      2020-05-01     20300\n   6 │ store3      2020-06-01     20400\n   7 │ store3      2020-07-01      5000\n\njulia> storeid(x) = parse(Int, replace(x, \"store\"=>\"\"))\nstoreid (generic function with 1 method)\njulia> function SALE(x)\n           if x < 10000\n               \"low\"\n           elseif x < 20000\n               \"average\"\n           elseif x < 21000\n               \"high\"\n           elseif x >= 21000\n               \"excellent\"\n           else\n               missing\n           end\n       end\nSALE (generic function with 1 method)\n\njulia> setformat!(sale, 1 => storeid, :date => month, :sale => SALE)\n7×3 Dataset\n Row │ store       date   sale\n     │ storeid     month  SALE\n     │ String?     Date?  Int64?\n─────┼──────────────────────────────\n   1 │ 1           5        average\n   2 │ 1           6        average\n   3 │ 2           5           high\n   4 │ 2           6      excellent\n   5 │ 3           5           high\n   6 │ 3           6           high\n   7 │ 3           7            low\n\njulia> getformat(sale, \"date\")\nmonth (generic function with 3 methods)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"When the formatted values are not needed for some columns, a call to removeformat! can remove their formats,","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> removeformat!(sale, [1,2])\n7×3 Dataset\n Row │ store       date        sale\n     │ identity    identity    SALE\n     │ String?     Date?       Int64?\n─────┼───────────────────────────────────\n   1 │ store1      2020-05-01    average\n   2 │ store1      2020-06-01    average\n   3 │ store2      2020-05-01       high\n   4 │ store2      2020-06-01  excellent\n   5 │ store3      2020-05-01       high\n   6 │ store3      2020-06-01       high\n   7 │ store3      2020-07-01        low","category":"page"},{"location":"man/formats/#Modifying-a-data-set","page":"Formats","title":"Modifying a data set","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The following rules administrate how a column format will automatically be changed if a data set is modified:","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"As a general rule, the format of a column is preserved during different operations. For example, adding/removing a column to a data set don't change the format of the original/remaining columns.\nThe format of a column wouldn't change if only few observations are updated, modified, added, or deleted, however, if a column goes through a significant change (e.g. all values change, or the column is replaced), its format will be automatically removed.\nThe format of a column will be preserved during some operations where a new data set is created. For example, the combine function preserve the format of grouping variables. This feature will be discussed, in more details, when those operations are introduced in later sections.","category":"page"},{"location":"man/formats/#format-validation","page":"Formats","title":"format validation","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"Datasets doesn't validate the supplied format until it needs to use the formatted values for an operation, in that case, if the supplied format is not a valid format, Datasets will throw errors.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In the following examples we demonstrate some scenarios which end up with an invalid format, and provide some remedies to fix the issues. Nevertheless, note that supplying an invalid format will not damage a data set and a simple call to removeformat! can be helpful to recover the original data set.","category":"page"},{"location":"man/formats/#Examples-3","page":"Formats","title":"Examples","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"First we create a data set and define a format.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ds = Dataset(x1 = [-1, 0, 1], x2 = [1.1, missing, 2.2], x3 = [1,2,3])\n3×3 Dataset\n Row │ x1        x2         x3\n     │ identity  identity   identity\n     │ Int64?    Float64?   Int64?\n─────┼───────────────────────────────\n   1 │       -1        1.1         1\n   2 │        0  missing           2\n   3 │        1        2.2         3\n\njulia> custom_format(x) = x[2]\ncustom_format (generic function with 1 method)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The function supplied as format is not defined for some values: In this example, we use sqrt as :x1's format, but :x1 contains negative values and sqrt is not defined for negative integers. Running the following expression will throw bunch of errors, because after setting format Datasets is trying to display the data set, but it cannot do that.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> setformat!(ds, 1 => sqrt)\nError showing value of type Dataset:\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n  .\n  .\n  .","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"This issue can be solve manually by defining a user defined format:","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> sqrt_fmt(x) = isless(x, 0) ? \"invalid\" : sqrt(x)\nsqrt_fmt (generic function with 1 method)\n\njulia> setformat!(ds, 1 => sqrt_fmt)\n3×3 Dataset\n Row │ x1         x2         x3\n     │ sqrt_fmt   identity   identity\n     │ Int64?     Float64?   Int64?\n─────┼────────────────────────────────\n   1 │ invalid          1.1         1\n   2 │       0.0  missing           2\n   3 │       1.0        2.2         3","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"Ignoring missing values: In this example, we use ROUND(x) = round(Int, x) as :x2 format, however, round(Int, x) doesn't know how to deal with missing values, thus, the same as the above example, Datasets will throw errors.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ROUND(x) = round(Int, x)\nROUND (generic function with 1 method)\n\njulia> setformat!(ds, 2 => ROUND)\nError showing value of type Dataset:\nERROR: MissingException: cannot convert a missing value to type Int64: use Union{Int64, Missing} instead\nStacktrace:\n\t.\n\t.\n\t.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"To solve this issue, we can redefine ROUND as","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"ROUND(x) = ismissing(x) ? missing : round(Int, x)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"or","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"ROUND(x) = round(Union{Int, Missing}, x)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"and every thing should be fine. Note that after updating the definition of ROUND, Datasets automatically fixes the formatted values of :x2","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ROUND(x) = ismissing(x) ? missing : round(Int, x)\nROUND (generic function with 1 method)\n\njulia> ds\n3×3 Dataset\n Row │ x1         x2        x3\n     │ sqrt_fmt   ROUND     identity\n     │ Int64?     Float64?  Int64?\n─────┼───────────────────────────────\n   1 │ invalid           1         1\n   2 │       0.0   missing         2\n   3 │       1.0         2         3","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The function defined as format assumes the input argument is a vector: In this example custom_format (defined earlier) is used for the third column. custom_format is defined in such a way that it assumes the input argument is a vector, but Datasets applies format to each value. ","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> setformat!(ds, 3=>custom_format)\nError showing value of type Dataset:\nERROR: BoundsError\nStacktrace:\n    .\n    .\n    .","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"To fix the issue we should redefine custom_format or simply remove the column's format:","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> removeformat!(ds, 3)\n3×3 Dataset\n Row │ x1         x2        x3\n     │ sqrt_fmt   ROUND     identity\n     │ Int64?     Float64?  Int64?\n─────┼───────────────────────────────\n   1 │ invalid           1         1\n   2 │       0.0   missing         2\n   3 │       1.0         2         3","category":"page"},{"location":"man/map/#Function-map/map!","page":"Call functions on each observation","title":"Function map/map!","text":"","category":"section"},{"location":"man/map/#Introduction","page":"Call functions on each observation","title":"Introduction","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"There are multiple ways to call a function on individual values (observations) of a column. In this section we discuss two of them: map! and map. These two functions are high-performance and customised version of map! and map in Julia Base.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"map! and map call functions on the actual values, i.e. if the column is formatted the functions are called on the values which may be different from what you see when show a data set.","category":"page"},{"location":"man/map/#map!","page":"Call functions on each observation","title":"map!","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The Datasets' map! function modifies a data set in-place by calling a function on individual values of a column. The syntax for the function is","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"map!(ds, fun, cols; threads = true)","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"where ds is a data set, and cols can be a single column or multiple columns selector. When fun is a single function, map! call that function on all values of cols. Since map! is modifying the data set ds in-place, it will skip columns in cols where fun changes the type of columns, and print a warning on the screen.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The threads = true keyword argument causes map! to exploit all cores available to Julia for doing the calculations. This is particularly useful when the fun function is expensive to calculate.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"When fun is a vector of functions and cols refers to multiple columns, map! calls each element of fun to the values of the corresponding column in cols. this means that it is possible to call different functions on different columns of a data set, however, the length of fun and the number of selected columns must be the same.","category":"page"},{"location":"man/map/#Examples","page":"Call functions on each observation","title":"Examples","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"In the following data set we like to replace every missing in :x2 and :x3 with value 0. Thus, we use map! and a suitable function to do this:","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\n\njulia> map!(ds, x -> ismissing(x) ? 0 : x, 2:3)\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3         0       0.2\n   4 │        4         1       0.0\n   5 │        5         2       0.4","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"Now let's call sqrt on all values. Note that sqrt of an integer is a float and sqrt of negative integer is not valid in Julia. So map! only applies the provided function on the last column and skips the first two columns.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> map!(ds, sqrt, :)\n┌ Warning: cannot map `f` on ds[!, :x1] in-place, the selected column is Union{Missing, Int64} and the result of calculation is Union{Missing, Float64}\n└ @ InMemoryDatasets ~/.julia/dev/InMemoryDatasets/src/dataset/other.jl:394\n┌ Warning: cannot map `f` on ds[!, :x2] in-place, the selected column is Union{Missing, Int64} and the result of calculation is Union{Missing, Float64}\n└ @ InMemoryDatasets ~/.julia/dev/InMemoryDatasets/src/dataset/other.jl:394\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2  0.0\n   2 │        2        -1  0.316228\n   3 │        3         0  0.447214\n   4 │        4         1  0.0\n   5 │        5         2  0.632456","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"As another example let's look at a data set where a column already has a format.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [1,2,1,2,1])\njulia> setformat!(ds, 1=>isodd)\n5×2 Dataset\n Row │ x1      x2\n     │ isodd   identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │   true         1\n   2 │  false         2\n   3 │   true         1\n   4 │  false         2\n   5 │   true         1\n\njulia> map!(ds, x->div(x,2), 1:2)\n5×2 Dataset\n Row │ x1      x2\n     │ isodd   identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │  false         0\n   2 │   true         1\n   3 │   true         0\n   4 │  false         1\n   5 │  false         0","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"Note that the format of :x1 is preserved and the function call changed the actual values. Thus, Datasets applies the format of :x1 to new values.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The following example shows how different functions can be used for different columns.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\n\njulia> fun_vec = [x -> div(x, 2),\n                  x -> ismissing(x) ? 0 : x,\n                  sqrt]\n3-element Vector{Function}:\n #5 (generic function with 1 method)\n #6 (generic function with 1 method)\n sqrt (generic function with 19 methods)\n\njulia> map!(ds, fun_vec, 1:3)\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼────────────────────────────────────\n   1 │        0        -2        0.0\n   2 │        1        -1        0.316228\n   3 │        1         0        0.447214\n   4 │        2         1  missing\n   5 │        2         2        0.632456","category":"page"},{"location":"man/map/#map","page":"Call functions on each observation","title":"map","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The map function also calls a function (or a vector of functions) on single or muliple columns of a data set. However, it differs from map! that we discussed earlier in three main areas,","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"it doesn't do in-place operation and returns a copy of the data set,\nunlike map!, it can change the type of columns, and\nit doesn't preserve the formats of the columns that are going to be modified.","category":"page"},{"location":"man/map/#Examples-2","page":"Call functions on each observation","title":"Examples","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"In the following example we call x -> x/2 on all columns. However, note that map automatically changes the data type of the first two columns, and more importantly it doesn't modify the original data set:","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\njulia> map(ds, x -> x/2, r\"x\")\n5×3 Dataset\n Row │ x1        x2         x3\n     │ identity  identity   identity\n     │ Float64?  Float64?   Float64?\n─────┼─────────────────────────────────\n   1 │      0.5       -1.0        0.0\n   2 │      1.0       -0.5        0.05\n   3 │      1.5  missing          0.1\n   4 │      2.0        0.5  missing\n   5 │      2.5        1.0        0.2\n\njulia> ds # map doesn't modify the original data set\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼───────────────────────────────\n   1 │        1        -2        0.0\n   2 │        2        -1        0.1\n   3 │        3   missing        0.2\n   4 │        4         1  missing\n   5 │        5         2        0.4","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"In the following example, we map some functions on columns of a data set which one the column has a format.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [1,2,1,2,1])\njulia> setformat!(ds, 1=>isodd)\n5×2 Dataset\n Row │ x1      x2\n     │ isodd   identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │   true         1\n   2 │  false         2\n   3 │   true         1\n   4 │  false         2\n   5 │   true         1\n\njulia> map(ds, [x -> div(x,2), x -> x/2], :)\n5×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        0       0.5\n   2 │        1       1.0\n   3 │        1       0.5\n   4 │        2       1.0\n   5 │        2       0.5","category":"page"},{"location":"man/modify/#Transforming-data-sets","page":"Transform columns","title":"Transforming data sets","text":"","category":"section"},{"location":"man/modify/#Introduction","page":"Transform columns","title":"Introduction","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The modify! function can be used to transform and modify columns of a data set. Note that the function modifies the data set in-place and operates on actual values (rather than the formatted values). To modify a copy of data we should use the modify function. These two functions accept one column of data set and apply the provided functions on the fed column as a vector, this should be compared to map!/map functions which apply operations on individual observations.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"Note that modify!/modify remove the format of columns as soon as their values are updated by a given transformation.","category":"page"},{"location":"man/modify/#Specifying-the-transformation","page":"Transform columns","title":"Specifying the transformation","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The first argument of these two functions is the name of the data set which is going to be modified and the next arguments can be the transform specifications, i.e.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, args...) or modify(ds, args...)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The simplest form of args is col => fun which calls fun on col as a vector and replaces col with the output of the call. col can be a column index or a column name. Thus, to replace the value of a column which is called :x in a data set ds with their standardised values, we can use the following expression:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, :x1 => stdze)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"where :x1 is a column in ds, and stdze is a function which subtracts values by their mean and divide them by their standard deviation. If you don't want to replace the column, but instead you like to create a new column based on calling fun on col, the col => fun => :newname (here :newname is a name for the new column) form is handy. Thus, to standardised the values of a column, which is called :x1, and store them as a new column in the data set, you  can use,","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, :x1 => stdze => :x1_stdze)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"To modify multiple columns of a data set with the same fun, we can use the cols => fun, where cols is a set of columns, this includes, a vector of columns indices, a vector of column names, a regular expression which selects some of the variables based on their names, or Between and Not types. When cols is referring to multiple columns, modify! automatically expands cols => fun to col1 => fun, col2 => fun, ..., where col1 is the first column in the selected columns, col2 is the second one, and so on. Thus to standardised all columns which starts with x in a data set, we can use the following expression:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, r\"^x\" => stdze)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"Note that the Julia broadcasting can be also used for specifying args..., e.g. something like:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"[1, 2, 3] .=> [stdze, x -> x .- mean(x), x -> x ./ sum(x)] .=> [:stdze_1, :m_2, :m_3]","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"will be translated as:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"1 => stdze => :stdze_1, 2 => (x -> x .- mean(x)) => :m_2, 3 => (x -> x ./ sum(x)) => :m_3,","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"and something like:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":":x1 .=> [sum, sort] .=> [:x1_sum, :x1_sort]","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"will be translated as:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":":x1 => sum => :x1_sum, :x1 => sort => :x1_sort.","category":"page"},{"location":"man/modify/#Examples","page":"Transform columns","title":"Examples","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\n\njulia> modify!(ds, 2:3 => sum)\n5×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1         0       0.7\n   2 │        2         0       0.7\n   3 │        3         0       0.7\n   4 │        4         0       0.7\n   5 │        5         0       0.7\n\njulia> modify!(ds, :x1 => x -> x .- mean(x))\n5×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Float64?  Int64?    Float64?\n─────┼──────────────────────────────\n   1 │     -2.0         0       0.7\n   2 │     -1.0         0       0.7\n   3 │      0.0         0       0.7\n   4 │      1.0         0       0.7\n   5 │      2.0         0       0.7","category":"page"},{"location":"man/modify/#Accessing-to-modified-columns","page":"Transform columns","title":"Accessing to modified columns","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"One of the key features of modify!/modify is that these functions have access to all modified/created variable in a single run of the function. It means, every transformation can be done on all columns that have been or updated by args arguments or any column which is created by col => fun => :newname syntax. In other words, for args... from left to right whenever a column is updated or created, the next operation has access to its value (either new or updated values). This will be particularly useful in conjunction with byrow which performs row-wise operations.","category":"page"},{"location":"man/modify/#Specialised-functions","page":"Transform columns","title":"Specialised functions","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"There are two functions in Datasets which are very handy to modify a data set: byrow, and splitter.","category":"page"},{"location":"man/modify/#byrow","page":"Transform columns","title":"byrow","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The byrow function is discussed in length in another section as a stand-alone function, however, it can also be used as the fun when we want to specify the transformation in modify!/modify. The syntax of byrow is different from its stand-alone usage in the way that when byrow is the fun part of args in the syntax of modify!/modify functions, we don't need to specify ds and cols, however, every other arguments are the same as the stand-alone usage.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The main feature of byrow inside modify!/modify  is that it can accept multiple columns as the input argument, opposed to the other functions inside modify!/modify which only accept single column. This and the fact that every transformation inside modify!/modify has access to modified columns, help to provide complex transformations in a single run of modify!/modify.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The form of args when byrow is the function is similar to other functions with the following exceptions:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"When cols refers to multiple columns in cols => byrow(...), modify!/modify will create a new column with a names based on the arguments passed to it. The user can provide a custom name by using the cols => byrow(...) => :newname syntax.\nWhen col refers to a single column in col => byrow(...), modify!/modify will apply operation on single values of the column and replace the column with the new values, i.e. it doesn't create a new column.\nTo use broadcasting with byrow, i.e. applying the same row-wise operation on multiple columns, the form must be cols .=> byrow where cols is a vector of column names or column indices (regular expression cannot be used for this purpose).","category":"page"},{"location":"man/modify/#splitter","page":"Transform columns","title":"splitter","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"splitter is also a specialised function which has a single job: splitting a single column which is a Tuple of values into multiple columns. It only operates on a single columns and the values inside the column which needs to be split must be in the form of Tuples. The form of args for splitter must be similar to:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, col => splitter => [:new_col_1, :new_col_2])","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"which means we like to split col into two new columns; :new_col_1 and :new_col_2. Here col can be a column index or a column name.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"Note, splitter produces as many columns as the length of the given new names, i.e. if the user provides fewer names than needed, the output columns will only contain partial components of the input Tuple.","category":"page"},{"location":"man/modify/#Examples-2","page":"Transform columns","title":"Examples","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"julia> body = Dataset(weight = [78.5, 59, 80], height = [160, 171, 183])\n3×2 Dataset\n Row │ weight    height   \n     │ identity  identity\n     │ Float64?  Int64?   \n─────┼────────────────────\n   1 │     78.5       160\n   2 │     59.0       171\n   3 │     80.0       183\n\njulia> modify!(body, :height => byrow(x -> (x/100)^2) => :BMI, [1, 3] => byrow(/) => :BMI)\n3×3 Dataset\n Row │ weight    height    BMI      \n     │ identity  identity  identity\n     │ Float64?  Int64?    Float64?\n─────┼──────────────────────────────\n   1 │     78.5       160   30.6641\n   2 │     59.0       171   20.1771\n   3 │     80.0       183   23.8884\n\njulia> sale = Dataset(customer = [\"Bob Smith\", \"John Max\", \"Froon Moore\"],\n       item1_q1 = [23, 43, 50], item2_q1 = [44, 32, 55],\n       item3_q1 = [45, 45, 54])\n3×4 Dataset\n Row │ customer     item1_q1  item2_q1  item3_q1\n     │ identity     identity  identity  identity\n     │ String?      Int64?    Int64?    Int64?   \n─────┼───────────────────────────────────────────\n   1 │ Bob Smith          23        44        45\n   2 │ John Max           43        32        45\n   3 │ Froon Moore        50        55        54\n\njulia> modify!(sale, 2:4 => byrow(sum) => :total)\n3×5 Dataset\n Row │ customer     item1_q1  item2_q1  item3_q1  total    \n     │ identity     identity  identity  identity  identity\n     │ String?      Int64?    Int64?    Int64?    Int64?   \n─────┼─────────────────────────────────────────────────────\n   1 │ Bob Smith          23        44        45       112\n   2 │ John Max           43        32        45       120\n   3 │ Froon Moore        50        55        54       159\n\njulia> julia> function name_split(x)\n           spl = split(x, \" \")\n           (string(spl[1]), string(spl[2]))\n       end\nname_split (generic function with 1 method)\n\njulia> modify!(sale, :customer => byrow(name_split),\n                     :customer => splitter => [:first_name, :last_name])\n3×7 Dataset\n Row │ customer            item1_q1  item2_q1  item3_q1  total     first_name  last_name\n     │ identity            identity  identity  identity  identity  identity    identity  \n     │ Tuple…?             Int64?    Int64?    Int64?    Int64?    String?     String?   \n─────┼───────────────────────────────────────────────────────────────────────────────────\n   1 │ (\"Bob\", \"Smith\")          23        44        45       112  Bob         Smith\n   2 │ (\"John\", \"Max\")           43        32        45       120  John        Max\n   3 │ (\"Froon\", \"Moore\")        50        55        54       159  Froon       Moore\n","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"In the last example, we use byrow to apply name_split on each row of :customer, and since there is only one column as the input of byrow, modify! replaces the column with the new values. Also, note that the modify! function has access to these new values and we can use splitter to split the column into two new columns.","category":"page"},{"location":"#InMemoryDatasets.jl","page":"Introduction","title":"InMemoryDatasets.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the InMemoryDatasets.jl documentation!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This resource aims to teach you everything you need to know to get up and running with the InMemoryDatasets.jl package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In memory Datasets is a collection of tools for working (manipulating, wrangling, cleaning, summarising,...) with tabular data in Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you are new to InMemoryDatasets.jl, probably First steps with Datasets or tutorial in manual should be good starting points.","category":"page"},{"location":"#Package-manual","page":"Introduction","title":"Package manual","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"man/basics.md\",\n         \"man/tutorial.md\",\n         \"man/formats.md\",\n         \"man/map.md\",\n         \"man/byrow.md\",\n         \"man/filter.md\",\n         \"man/sorting.md\",\n         \"man/grouping.md\",\n         \"man/modify.md\",\n         \"man/aggregation\",\n         \"man/transpose.md\",\n         \"man/joins.md\"]\nDepth = 2","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported (i.e. available for use without InMemoryDatasets. qualifier after loading the InMemoryDatasets.jl package with using InMemoryDatasets) types and functions are considered a part of the public API of the InMemoryDatasets.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please be warned that while Julia allows you to access internal functions or types of InMemoryDatasets.jl these can change without warning between versions of InMemoryDatasets.jl. In particular it is not safe to directly access fields of types that are a part of public API of the InMemoryDatasets.jl package using e.g. the getfield function. Whenever some operation on fields of defined types is considered allowed an appropriate exported function should be used instead.","category":"page"},{"location":"man/byrow/#Function-byrow","page":"Row-wise operations","title":"Function byrow","text":"","category":"section"},{"location":"man/byrow/#Introduction","page":"Row-wise operations","title":"Introduction","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The byrow function is a high performance (multi-threaded) function for row-wise operations. It is designed to make tasks like summing up each row simple, efficient, and lightening fast. The function can be used as a stand-alone function or inside modify or combine functions. The stand-alone syntax of the function is byrow(ds, fun, cols, ...), where ds is a data set, fun is a function, and cols  is the list of columns which row-wise operation is going to be applied on their values in each row, e.g. the following code creates a data set with 100,000 rows and 100 columns, and adds the values in each row,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds = Dataset(rand(10^5, 100), :auto);\njulia> byrow(ds, sum, 1:100)\n100000-element Vector{Union{Missing, Float64}}:\n 50.655934293702366\n 51.481108371018266\n 51.27498152964299\n 54.097941432844536\n 52.28727157779627\n 56.215091415376975\n 53.940023864095856\n 47.65424080373157\n  ⋮\n 46.360565247921\n 45.91721147194705\n 52.047072415296824\n 48.71125460530455\n 50.82102574082131\n 49.90462723123929\n 46.594683329278816\n 50.47529543725829","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"As it can be observed the function syntax is very straightforward, and to examine the efficiency of it, we use the @btime macro from the BenchmarkTools package,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> using BenchmarkTools\njulia> @btime byrow(ds, sum, 1:100);\n  7.874 ms (2143 allocations: 1.02 MiB)\njulia> m = Matrix(ds)\njulia> @btime sum(m, dims = 2)\n  20.773 ms (7 allocations: 879.11 KiB)","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"In the above benchmark, you should expect even more difference when the data set has a group of heterogeneous columns.","category":"page"},{"location":"man/byrow/#Optimised-operations","page":"Row-wise operations","title":"Optimised operations","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Generally, byrow is very efficient for any fun which returns a single value for each row, however, it is fine tuned for the following functions:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"all\nany\ncount\nhash\nmaximum\nmean\nminimum\nnunique\nprod\nstd\nsum\nvar","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The common syntax of byrow for all of these functions except nunique is:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"byrow(ds, fun, cols; [by , threads = true])","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The by keyword argument is for giving a function to call on each value before calling fun to aggregate the values, and threads = true causes byrow to exploit all cores available to Julia for performing the computations. ","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The nunique function doesn't accept threads argument, however, it has an extra keyword argument count_missing. nunique counts the number of unique value of each row, and count_missing = true counts missings as a unique value. ","category":"page"},{"location":"man/byrow/#Examples","page":"Row-wise operations","title":"Examples","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Let's first create an example data set which we will use for the rest of this section:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds = Dataset(g = [1, 1, 1, 2, 2],\n                    x1_int = [0, 0, 1, missing, 2],\n                    x2_int = [3, 2, 1, 3, -2],\n                    x1_float = [1.2, missing, -1.0, 2.3, 10],\n                    x2_float = [missing, missing, 3.0, missing, missing],\n                    x3_float = [missing, missing, -1.4, 3.0, -100.0])\n5×6 Dataset\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float\n     │ identity  identity  identity  identity   identity   identity\n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?\n─────┼───────────────────────────────────────────────────────────────\n   1 │        1         0         3        1.2  missing    missing\n   2 │        1         0         2  missing    missing    missing\n   3 │        1         1         1       -1.0        3.0       -1.4\n   4 │        2   missing         3        2.3  missing          3.0\n   5 │        2         2        -2       10.0  missing       -100.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To compute the mean of each row for the float columns, we simply call, ","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, mean, r\"_float\")\n5-element Vector{Union{Missing, Float64}}:\n   1.2\n    missing\n   0.20000000000000004\n   2.65\n -45.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that, since for the second row all values are missing, the result of mean is also missing.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To calculate the mean of the absolute value of each row for the float columns we use the same code and add by = abs as the keyword argument,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, mean, r\"_float\", by = abs)\n5-element Vector{Union{Missing, Float64}}:\n  1.2\n   missing\n  1.8\n  2.65\n 55.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To find rows which all their values are greater than 0 in the first three columns we can use the following code, ","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, all, 1:3, by = x -> isless(0, x))\n5-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that in Julia isless(0, missing) is true.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To find rows which contain at least one missing value in any of the columns we can use the following code, ","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, any, :, by = ismissing)\n5-element Vector{Bool}:\n 1\n 1\n 0\n 1\n 1","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"It means that except the third row, all other rows contain missing values. Using byrow with count function, we can count the number of non-missing values in each row, ","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, count, :, by = !ismissing)\n5-element Vector{Int32}:\n 4\n 3\n 6\n 4\n 5","category":"page"},{"location":"man/byrow/#User-defined-operations","page":"Row-wise operations","title":"User defined operations","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"For user defined functions which return a single value, byrow treats each row as a vector of values, thus the user defined function must accept a vector and returns a single value. For instance to calculate 1 * col1 + 2 * col2 + 3 * col3 for each row in ds we can define the following function:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> avg(x) = 1 * x[1] + 2 * x[2] + 3 * x[3]\navg (generic function with 1 method)","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"and directly use it in byrow, ","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, avg, 1:3)\n5-element Vector{Union{Missing, Int64}}:\n 10\n  7\n  6\n   missing\n  0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that avg is missing if any of the values in x is missing.","category":"page"},{"location":"man/byrow/#Special-operations","page":"Row-wise operations","title":"Special operations","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"byrow also supports a few optimised operations which return a vector of values for each row. The fun argument for these operations is one the followings:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"cumprod\ncumprod!\ncumsum\ncumsum!\nsort\nsort!\nstdze\nstdze!","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The main difference between these operations and the previous operations is that these operations return a data set with the corresponding row has been updated with the operation. For the operations with ! the updated version of the original data set is returned and for the operations without ! a modified copy of the original data set is returned.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"cumsum and cumprod calculate the cumulative sum and cumulative product of rows, respectively, sort sorts the values in each row, and stdze standardises the values in each row. The sort operation accepts all keyword arguments that the function sort in Julia Base accept.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, cumsum, 1:3)\n5×6 Dataset\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float\n     │ identity  identity  identity  identity   identity   identity\n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?\n─────┼───────────────────────────────────────────────────────────────\n   1 │        1         1         4        1.2  missing    missing\n   2 │        1         1         3  missing    missing    missing\n   3 │        1         2         3       -1.0        3.0       -1.4\n   4 │        2         2         5        2.3  missing          3.0\n   5 │        2         4         2       10.0  missing       -100.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that for these operations, cumsum treats missing as zero, and cumprod treats missing as one.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The special operations don't change the columns names or their orders.","category":"page"},{"location":"assets/README/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"In this folder we store the following data sets:","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"german_credit.csv\niris.csv","category":"page"},{"location":"assets/README/#German-Credit-data-set","page":"Introduction","title":"German Credit data set","text":"","category":"section"},{"location":"assets/README/#License:","page":"Introduction","title":"License:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://opendatacommons.org/licenses/dbcl/1-0/","category":"page"},{"location":"assets/README/#Source:","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/statlog+(german+credit+data) Professor Dr. Hans Hofmann Institut für Statistik und Ökonometrie Universität Hamburg FB Wirtschaftswissenschaften Von-Melle-Park 5 2000 Hamburg 13","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"The original data is from UCI, and the file stored here is from Kaggle","category":"page"},{"location":"assets/README/#Iris-data-set","page":"Introduction","title":"Iris data set","text":"","category":"section"},{"location":"assets/README/#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://creativecommons.org/publicdomain/zero/1.0/","category":"page"},{"location":"assets/README/#Source:-2","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/Iris Creator: R.A. Fisher","category":"page"}]
}
